---
title: "Li et al breast cancer dataset: `r params$sample_name`"
output: html_notebook
params:
  sample_name: "V10F24-112_C1"
---
From Computational pathology annotation enhances the resolution and interpretation of breast cancer spatial transcriptomics data

Paper: https://doi.org/10.1038/s41698-025-01104-3

Zenodo: https://zenodo.org/records/15211538

No mito genes here either!

## Set up

```{r}
repo_root <- rprojroot::find_root(rprojroot::is_git_root)
renv::load(repo_root)

suppressPackageStartupMessages({
  library(SpotSweeper)
  library(SpatialExperiment)
  library(scuttle)
  library(ggplot2)
  library(patchwork)
  library(VisiumIO)
})

set.seed(2025)
```




## Read! 


```{r}
data_path <- file.path(
  repo_root, 
  "data", 
  "2025-11_data", 
  "Li-breast-zenodo-15211538", 
  "spaceranger_output"
) 
sample_dir <- file.path(data_path, params$sample_name, "outs")

# use type="sparse" for the directory; default wants the h5 file
# note that if we wanted the raw matrix, use data = "raw"
spe <- SpatialExperiment::read10xVisium(samples = sample_dir, type = "sparse")
# this will already be the case when reading in the filtered matrix but it's a good cue
spe <- spe[, spe$in_tissue == 1] 
spe
```

First we'll subset to only spots in tissue and visualize the data pre-filtering.

```{r, warning = FALSE}
# I turned off warnings since this spits out an aes_string() depr warning
ggspavis::plotVisium(spe, zoom = TRUE) + ggspavis::plotVisium(spe, spots = FALSE)
```

## QC 

We'll detect local outliers with SpotSweeper, viz, and filter them.

```{r}
# add qc metrics
spe <- addPerCellQCMetrics(spe, subsets= list(mito=grep("^MT-", rowData(spe)$Symbol)))

# these all get named in the colData as "{metric}_outliers"
# library size
spe <- localOutliers(spe,
    metric = "sum",
    direction = "lower",
    log = TRUE
) ### --> sum_outliers

# unique genes
spe <- localOutliers(spe,
    metric = "detected",
    direction = "lower",
    log = TRUE
) #---> detected_outliers

# mitochondrial percent
spe <- localOutliers(spe,
    metric = "subsets_mito_percent",
    direction = "higher",
    log = FALSE
) #----> subsets_mito_percent_outliers


# combine all the outlier detections into a single column:
# combine all outliers into "local_outliers" column
spe$local_outliers <- as.logical(spe$sum_outliers) |
    as.logical(spe$detected_outliers) |
    as.logical(spe$subsets_mito_percent_outliers)
```


```{r}
table(spe$local_outliers)
```

Plot some QC metrics:

```{r}
a <- ggspavis::plotCoords(spe, annotate = "subsets_mito_percent")
b <- ggspavis::plotCoords(spe, annotate = "sum")
cc <- ggspavis::plotCoords(spe, annotate = "detected")
d <- ggspavis::plotCoords(spe, annotate = "local_outliers") + 
  scale_color_manual(values = c("gray90", "red"))

patchwork::wrap_plots(a, b, cc, d, nrow =2)
```

Filter them out:

```{r}
spe <- spe[, !spe$local_outliers]
```


And show where we are now:

```{r}
spe
```


## Normalization

```{r}
spe <- scuttle::computeLibraryFactors(spe)
spe <- logNormCounts(spe)
```


## Dimension reduction & clustering

We'll do dimension reduction and clustering in a few ways:

- Using `BANKSY` PCA with `lambda = 0.2` for spatial domains, with AGF turned on
- Using `BayesSpace` 
- Non-spatial using `scuttle` with HVGs for PCA

All clustering will be louvain with 20 nearest neighbors, resolution of 1.
We'll plot the results on UMAPs and the spatial coordinates.

```{r, warning=FALSE, message=FALSE}
lambda <- c(0, 0.2)
k_geom <- 18  

# adds assays and metadata
spe <- Banksy::computeBanksy(spe,  compute_agf = TRUE, assay_name = "logcounts", k_geom = k_geom)
spe <- Banksy::runBanksyPCA(spe, use_agf = TRUE, lambda = lambda)
spe <- Banksy::runBanksyUMAP(spe, use_agf = TRUE, lambda = lambda)
colData(spe)$banksy_clusters <- scran::clusterCells(spe, use.dimred = "PCA_M1_lam0.2", BLUSPARAM = bluster::NNGraphParam(
    k = 20,
    cluster.fun = "louvain"
  ))
```


```{r}
# "regular" pca
gene_variance <- scran::modelGeneVar(spe)
highvar_genes <- scran::getTopHVGs(spe, n = 2000) 
spe <- scater::runPCA(spe, subset_row = highvar_genes)
spe <- scater::runUMAP(spe)
colData(spe)$regular_clusters <- scran::clusterCells(spe, use.dimred = "PCA", BLUSPARAM = bluster::NNGraphParam(
    k = 20,
    cluster.fun = "louvain"
  ))
```



```{r, fig.width  = 14, fig.height = 5}
umap_plot <- scater::plotReducedDim(spe, dimred = "UMAP_M1_lam0.2", color_by = "banksy_clusters") + ggtitle("Bansky lambda = 0.2") + theme(legend.position = "bottom") +
  scater::plotUMAP(spe, color_by = "regular_clusters") + ggtitle("Regular") + theme(legend.position = "bottom")
umap_plot
```


```{r, fig.width  = 12, fig.height = 4}
coord_plot <- ggspavis::plotCoords(spe, annotate = "banksy_clusters") + ggtitle("Bansky lambda=0.2") + theme(legend.position = "none") + 
  ggspavis::plotCoords(spe, annotate = "regular_clusters") + ggtitle("Regular")  + theme(legend.position = "none") +
  ggspavis::plotVisium(spe, zoom = TRUE, spots = FALSE)
coord_plot
  
```


## session info

```{r}
sessionInfo()
```

