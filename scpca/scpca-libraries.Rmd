---
title: "ScPCA Spatial library `r params$library_id`"
output: html_notebook
params:
  sample_id: "SCPCS000186"
  library_id: "SCPCL000456"
  n_order: 2
---

## Set up

```{r}
repo_root <- rprojroot::find_root(rprojroot::is_git_root)
renv::load(repo_root)

suppressPackageStartupMessages({
  library(SpotSweeper)
  library(SpatialExperiment)
  library(scuttle)
  library(ggplot2)
  library(patchwork)
  library(VisiumIO)
})

set.seed(123)
```




## Read! 


```{r}
data_path <- file.path(
  repo_root, 
  "data", 
  "SCPCP000006_SPATIAL_SINGLE-CELL-EXPERIMENT_2025-08-21", 
  glue::glue("{params$sample_id}/{params$library_id}_spatial"), 
  "outs" #space ranger output 
) 

# This is literally expecting a directory "outs" to be present in the data_path
tenx_object_raw_matrix <- VisiumIO::TENxVisium(
  resources = file.path(data_path, "filtered_feature_bc_matrix"),
  spatialResource = file.path(data_path, "spatial"),
  # NEEDED: the default includes `cytassist` and our samples don't have
  images = c("lowres", "hires", "detected", "aligned")
)

spe <- import(tenx_object_raw_matrix)
spe
```

First we'll subset to only spots in tissue and visualize the data pre-filtering.

```{r}
spe <- spe[, spe$in_tissue == 1] 
ggspavis::plotVisium(spe)
```

We'll also plot overall counts, to see how successful this experiment was in the first place.

```{r}
colData(spe)$raw_colsums <- colSums(counts(spe))
ggspavis::plotCoords(spe, annotate = "raw_colsums")
```


## QC 

Now we'll use `SpotSweeper` to filter out local outliers.
We're going to skip filtering on hangnail artifacts, but we'll look for them and plot them - this data isn't great quality so a lot gets lost if you filter and we're still doing proof of concept!

```{r}
# add qc metrics
spe <- addPerCellQCMetrics(spe, subsets= list(mito=grep("^MT-", rowData(spe)$Symbol)))

# these all get named in the colData as "{metric}_outliers"
# library size
spe <- localOutliers(spe,
    metric = "sum",
    direction = "lower",
    log = TRUE
) ### --> sum_outliers

# unique genes
spe <- localOutliers(spe,
    metric = "detected",
    direction = "lower",
    log = TRUE
) #---> detected_outliers

# mitochondrial percent
spe <- localOutliers(spe,
    metric = "subsets_mito_percent",
    direction = "higher",
    log = FALSE
) #----> subsets_mito_percent_outliers


# combine all the outlier detections into a single column:
# combine all outliers into "local_outliers" column
spe$local_outliers <- as.logical(spe$sum_outliers) |
    as.logical(spe$detected_outliers) |
    as.logical(spe$subsets_mito_percent_outliers)
```


```{r}
table(spe$local_outliers)
```


Plot it!


```{r, fig.width = 12}
metrics <- c("sum_log", "detected_log", "subsets_mito_percent")
plot_list <- metrics |>
  purrr::map(
  \(metric) {
        
    SpotSweeper::plotQCmetrics(
      spe, 
      metric = metric,
      outliers = "local_outliers", 
      point_size = 2,
      stroke = 1
    ) +ggtitle(glue::glue("{metric} with All Local Outliers"))
  }
)

spotplot <- wrap_plots(plot_list)
spotplot
```


Now, plot hangnail artifacts, side-by-side with the histology image to see if things match up.

```{r, fig.width = 10, fig.height = 4}
# find artifacts using SpotSweeper just to visualize
spe <- SpotSweeper::findArtifacts(
  spe,
  # The column name representing the mitochondrial percent.
  mito_percent = "subsets_mito_percent",
  # The column name representing sum mitochondrial expression.
  mito_sum = "subsets_mito_sum", 
  n_order = params$n_order
)

# visualize them
hangnail_plot <- plotQCmetrics(spe,
    metric = "subsets_mito_percent", # color points by
    outliers = "artifact",  # circle points in red
    point_size = 2, 
    stroke = 0.5 # outlier stroke
) +
    ggtitle("Hangnail artifact")

hangnail_plot + ggspavis::plotVisium(spe, spots = F) 
```


As stated though, we'll just filter out local outliers:

```{r}
spe <- spe[, !spe$local_outliers]
```

## Normalization

```{r}
spe <- scuttle::computeLibraryFactors(spe)
spe <- logNormCounts(spe)
```


## Dimension reduction & clustering

We'll do dimension reduction and clustering in a few ways:

- Using `BANKSY` PCA with `lambda = 0.2` for spatial domains, with AGF turned on
- Using `BANKSY` PCA with `lambda = 0` for "nonspatial clustering" - but this doesn't seem to take HVGs into account?
- Using `scuttle` with HVGs for PCA

All clustering will be louvain with 20 nearest neighbors, resolution of 1.
We'll plot the results on UMAPs and the spatial coordinates.

```{r}
# 0.2 is the visium domain recommendation
lambda <- c(0, 0.2)
k_geom <- 18  # also recommended for visium; may not be ideal for this data since we have varying quality, but it's fine for a cursory look

# adds assays and metadata
spe <- Banksy::computeBanksy(spe,  compute_agf = TRUE, assay_name = "logcounts", k_geom = k_geom)
spe <- Banksy::runBanksyPCA(spe, use_agf = TRUE, lambda = lambda)
spe <- Banksy::runBanksyUMAP(spe, use_agf = TRUE, lambda = lambda)
colData(spe)$banksy_clusters <- scran::clusterCells(spe, use.dimred = "PCA_M1_lam0.2", BLUSPARAM = bluster::NNGraphParam(
    k = 20,
    cluster.fun = "louvain"
  ))
colData(spe)$banksy_nonspatial_clusters <- scran::clusterCells(spe, use.dimred = "PCA_M1_lam0", BLUSPARAM = bluster::NNGraphParam(
    k = 20,
    cluster.fun = "louvain"
  ))
```

```{r}
# "regular" pca
gene_variance <- scran::modelGeneVar(spe)
highvar_genes <- scran::getTopHVGs(spe, n = 2000) # TODO: Is 2000 still the move for spatial? Might depend on technology. For seq-based, sure, but image-based depends.
spe <- scater::runPCA(spe, subset_row = highvar_genes)
spe <- scater::runUMAP(spe)
colData(spe)$regular_clusters <- scran::clusterCells(spe, use.dimred = "PCA", BLUSPARAM = bluster::NNGraphParam(
    k = 20,
    cluster.fun = "louvain"
  ))
```



```{r, fig.width  = 14, fig.height = 5}
umap_plot <- scater::plotReducedDim(spe, dimred = "UMAP_M1_lam0.2", color_by = "banksy_clusters") + ggtitle("Bansky lambda = 0.2") + theme(legend.position = "bottom") +
  scater::plotReducedDim(spe, dimred = "UMAP_M1_lam0", color_by = "banksy_nonspatial_clusters") + ggtitle("Bansky lambda=0") + theme(legend.position = "bottom") +
  scater::plotUMAP(spe, color_by = "regular_clusters") + ggtitle("Regular") + theme(legend.position = "bottom")
umap_plot
```


```{r, fig.width  = 12, fig.height = 4}
coord_plot <- ggspavis::plotCoords(spe, annotate = "banksy_clusters") + ggtitle("Bansky lambda=0.2") + theme(legend.position = "none") + 
  ggspavis::plotCoords(spe, annotate = "banksy_nonspatial_clusters") + ggtitle("Bansky lambda=0") + theme(legend.position = "none") +
  ggspavis::plotCoords(spe, annotate = "regular_clusters") + ggtitle("Regular")  + theme(legend.position = "none")
coord_plot
```


## session info

```{r}
sessionInfo()
```

